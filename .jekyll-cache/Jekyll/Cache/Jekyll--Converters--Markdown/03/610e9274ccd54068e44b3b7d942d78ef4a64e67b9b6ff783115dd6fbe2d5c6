I"1<p>Packages in Open Peer Power provide a way to bundle different component’s configuration together. We already learned about the two configuration styles (specifying platforms entries together or individually) on the <a href="/docs/configuration/devices/">adding devices</a> page. Both of these configuration methods require you to create the integration key in the main <code>configuration.yaml</code> file. With packages we have a way to include different components, or different configuration parts using any of the <code>!include</code> directives introduced in <a href="/docs/configuration/splitting_configuration">splitting the configuration</a>.</p>
<p>Packages are configured under the core <code>openpeerpower/packages</code> in the configuration and take the format of a package name (no spaces, all lower case) followed by a dictionary with the package configuration. For example, package <code>pack_1</code> would be created as:</p>
<figure class="highlight"><pre><code class="language-yaml" data-lang="yaml">openpeerpower:
  ...
  packages: 
    pack_1:
      ...package configuration here...</code></pre></figure>
<p>The package configuration can include: <code>switch</code>, <code>light</code>, <code>automation</code>, <code>groups</code>, or most other Open Peer Power integrations including hardware platforms.</p>
<p>It can be specified inline or in a separate YAML file using <code>!include</code>.</p>
<p>Inline example, main <code>configuration.yaml</code>:</p>
<figure class="highlight"><pre><code class="language-yaml" data-lang="yaml">openpeerpower:
  ...
  packages: 
    pack_1:
      switch:
        - platform: rest
          ...
      light:
        - platform: rpi
          ...</code></pre></figure>
<p>Include example, main <code>configuration.yaml</code>:</p>
<figure class="highlight"><pre><code class="language-yaml" data-lang="yaml">openpeerpower:
  ...
  packages: 
    pack_1: !include my_package.yaml</code></pre></figure>
<p>The file <code>my_package.yaml</code> contains the “top-level” configuration:</p>
<figure class="highlight"><pre><code class="language-yaml" data-lang="yaml">switch:
  - platform: rest
    ...
light:
  - platform: rpi
    ...</code></pre></figure>
<p>There are some rules for packages that will be merged:</p>
<ol>
<li>
<p>Platform based integrations (<code>light</code>, <code>switch</code>, etc) can always be merged.</p>
</li>
<li>
<p>Components where entities are identified by a key that will represent the entity_id (<code>{key: config}</code>) need to have unique ‘keys’ between packages and the main configuration file.</p>
<p>For example if we have the following in the main configuration. You are not allowed to re-use “my_input” again for <code>input_boolean</code> in a package:</p>
</li>
</ol>
<figure class="highlight"><pre><code class="language-yaml" data-lang="yaml">input_boolean:
      my_input:</code></pre></figure>
<ol start="3">
<li>Any integration that is not a platform [2], or dictionaries with Entity ID keys [3] can only be merged if its keys, except those for lists, are solely defined once.</li>
</ol>
<div class='note tip'>
Components inside packages can only specify platform entries using configuration style 1, where all the platforms are grouped under the integration name.
</div>
<h3>Create a packages folder</h3>
<p>One way to organize packages is to create a folder named “packages” in your Open Peer Power configuration directory. In the packages directory you can store any number of packages in a YAML file. This entry in your <code>configuration.yaml</code> will load all packages:</p>
<figure class="highlight"><pre><code class="language-yaml" data-lang="yaml">openpeerpower:
  packages: !include_dir_named packages</code></pre></figure>
<p>This uses the concept splitting the configuration and will include all files in a directory with the keys representing the filenames.
See the documentation about <a href="/docs/configuration/splitting_configuration/">splitting the configuration</a> for more information about <code>!include_dir_named</code> and other include statements that might be helpful. The benefit of this approach is to pull all configurations required to integrate a system, into one file, rather than across several.</p>
<p>The following example allows to have subfolders in the <code>packages</code> folder, which could make managing multiple packages easier by grouping:</p>
<figure class="highlight"><pre><code class="language-yaml" data-lang="yaml">openpeerpower:
  packages: !include_dir_merge_named packages/</code></pre></figure>
<p>and in <code>packages/subsystem1/functionality1.yaml</code>:</p>
<figure class="highlight"><pre><code class="language-yaml" data-lang="yaml">subsystem1_functionality1:
  input_boolean:
  ...
  binary_sensor:
  ...
  automation:</code></pre></figure>
<h3>Customizing entities with packages</h3>
<p>It is possible to <a href="/docs/configuration/customizing-devices/">customize entities</a> within packages. Just create your customization entries under:</p>
<figure class="highlight"><pre><code class="language-yaml" data-lang="yaml">openpeerpower:
  customize:</code></pre></figure>
:ET